# =============================================================================
# Script: app.py
# =============================================================================
# Purpose
#   Expose a REST API that accepts JD, CV, and Skill Tree (plus optional
#   question guidelines) and returns the full agenda JSON generated by
#   AgendaGenerationAgent. Intended for synchronous, single-request use
#   with a configurable timeout.
#
# Behavior
#   - Defines a FastAPI app with a lifespan context:
#       * Startup: prepare lightweight shared resources (if any).
#       * Shutdown: close Mongo connections and clear shared objects.
#   - Provides endpoints:
#       * GET /health: liveness check.
#       * POST /agenda_create: runs the agenda pipeline and returns JSON.
#   - Builds an InputSchema from the request payload and forwards a
#     thread_id through config so downstream agents run accordingly and tag logs correctly.
#   - Normalizes Pydantic outputs to plain dicts before responding.
#   - Logs high-level events and converts internal failures to HTTP errors:
#       * 500 on unhandled exceptions.
#   - Leaves pipeline details (LLM retries, per-node logging) to the
#     underlying agents.
# =============================================================================

import asyncio
import logging
import os
from contextlib import asynccontextmanager
from typing import Any, Dict, Optional

import pymongo
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field
from pymongo.errors import PyMongoError

from src.agent.AgendaGenerationAgent import run_agenda_with_logging
from src.mongo_tools import close_all_mongo_connections
from src.schema.input_schema import (
    CandidateProfileSchema,
    InputSchema,
    JobDescriptionSchema,
    SkillTreeSchema,
)

APP_NAME = "agenda_api"
logger = logging.getLogger(APP_NAME)

# force this API to only show WARNING and above
if not logger.handlers:
    logging.basicConfig(
        level=logging.WARNING,  # <- key change
        format="%(asctime)s | %(levelname)s | %(name)s | %(message)s",
    )

# Simple in-memory job store
JOBS: Dict[str, Dict[str, Any]] = {}


@asynccontextmanager
async def lifespan(app: FastAPI):
    try:
        pass
    except Exception:
        logger.exception("Startup initialization failed")
        raise

    yield

    try:
        close_all_mongo_connections()
    except Exception:
        logger.warning("close_all_mongo_connections raised but continuing shutdown")
    JOBS.clear()


app = FastAPI(title="Agenda API", version="1.1.0", lifespan=lifespan)


# ----------------------------
# Models
# ----------------------------
class AgendaRequest(BaseModel):
    job_description: JobDescriptionSchema = Field(..., description="Job description")
    candidate_profile: CandidateProfileSchema = Field(
        ..., description="Candidate CV/profile"
    )
    skill_tree: SkillTreeSchema = Field(..., description="Skill tree")
    question_guidelines: Optional[Dict[str, Any]] = Field(
        default=None, description="Optional question guidelines dict"
    )
    config: Optional[Dict[str, Any]] = Field(
        default=None, description="Optional graph config to override defaults"
    )
    thread_id: Optional[str] = Field(
        default=None, description="Optional thread id for logging/tracing"
    )


class AgendaCreateResponse(BaseModel):
    job_id: str
    status: str
    thread_id: str


class AgendaStatusResponse(BaseModel):
    job_id: str
    status: str
    error: Optional[str] = None
    thread_id: Optional[str] = None


class AgendaResultResponse(BaseModel):
    job_id: str
    status: str
    result: Optional[Dict[str, Any]] = None
    error: Optional[str] = None
    thread_id: Optional[str] = None


# ----------------------------
# Mongo helpers
# ----------------------------
def _mongo_env() -> tuple[str, str, str]:
    uri = os.environ.get("MONGO_CLIENT")
    db = os.environ.get("MONGO_DB")
    coll = os.environ.get("MONGO_QUESTION_GENERATION_COLLECTION")
    missing = [
        k
        for k, v in {
            "MONGO_CLIENT": uri,
            "MONGO_DB": db,
            "MONGO_QUESTION_GENERATION_COLLECTION": coll,
        }.items()
        if not v
    ]
    if missing:
        raise RuntimeError(f"Missing Mongo env: {', '.join(missing)}")
    return uri, db, coll


def _upsert_question_guidelines(qg_payload: Optional[Dict[str, Any]]) -> None:
    """
    Upsert each guideline:
      _id = question_type_name
      doc = { _id, question_type_name, question_guidelines }
    Only WARNING/ERROR logs are allowed here.
    """
    if not qg_payload or not isinstance(qg_payload, dict):
        # was: logger.info(...)
        return

    items = qg_payload.get("question_guidelines")
    if not isinstance(items, list) or not items:
        # was: logger.info(...)
        return

    try:
        uri, db_name, coll_name = _mongo_env()
    except RuntimeError as e:
        # this is an actual issue, so WARNING
        logger.warning("Guidelines upsert skipped: %s", e)
        return

    client = None
    try:
        client = pymongo.MongoClient(uri, serverSelectionTimeoutMS=5000)
        coll = client[db_name][coll_name]
        for raw in items:
            if not isinstance(raw, dict):
                logger.warning("Skipping non-dictionary guideline entry: %r", raw)
                continue
            name = str(raw.get("question_type_name", "")).strip()
            text = str(raw.get("question_guidelines", "")).strip()
            if not name:
                logger.warning("Skipping guideline: empty 'question_type_name'")
                continue
            if not text:
                logger.warning(
                    "Skipping guideline '%s': empty 'question_guidelines'", name
                )
                continue

            doc = {"_id": name, "question_type_name": name, "question_guidelines": text}
            try:
                coll.replace_one({"_id": name}, doc, upsert=True)
            except PyMongoError as e:
                logger.error("Failed to upsert guideline '%s': %s", name, e)

        # was: logger.info("Question guidelines upsert complete ...")
        # skip info
    except PyMongoError as e:
        logger.error("Mongo error during guidelines upsert: %s", e)
    finally:
        if client:
            client.close()


# ----------------------------
# Helpers
# ----------------------------
def _normalize_output(otpt: Dict[str, Any]) -> Dict[str, Any]:
    norm: Dict[str, Any] = {}
    for k, v in otpt.items():
        key = str(k)
        try:
            if hasattr(v, "model_dump"):
                norm[key] = v.model_dump()
            elif hasattr(v, "dict"):
                norm[key] = v.dict()
            else:
                norm[key] = v
        except Exception:
            norm[key] = v
    return norm


async def _run_job(job_id: str, req: AgendaRequest):
    try:
        JOBS[job_id]["status"] = "running"

        _upsert_question_guidelines(req.question_guidelines)

        inp = InputSchema(
            job_description=req.job_description,
            skill_tree=req.skill_tree,
            candidate_profile=req.candidate_profile,
            question_guidelines=req.question_guidelines or {"question_guidelines": []},
        )

        # pass config as-is if you like, or wrap it
        out = await run_agenda_with_logging(inp, {"thread_id": req.thread_id})

        JOBS[job_id]["status"] = "done"
        JOBS[job_id]["result"] = _normalize_output(out)
    except Exception as e:
        JOBS[job_id]["status"] = "error"
        JOBS[job_id]["error"] = str(e)


# ----------------------------
# Routes
# ----------------------------
@app.get("/health")
async def health():
    return {"ok": True}


@app.post("/agenda_create", response_model=AgendaCreateResponse, status_code=202)
async def agenda_create(req: AgendaRequest):
    job_id = req.thread_id
    if not job_id:
        raise HTTPException(status_code=400, detail="thread_id is required")

    JOBS[job_id] = {
        "status": "queued",
        "result": None,
        "error": None,
        "thread_id": job_id,
    }
    asyncio.create_task(_run_job(job_id, req))

    return AgendaCreateResponse(job_id=job_id, status="queued", thread_id=job_id)


@app.get("/agenda_status/{job_id}", response_model=AgendaStatusResponse)
async def agenda_status(job_id: str):
    job = JOBS.get(job_id)
    if not job:
        raise HTTPException(status_code=404, detail="job_id not found")
    return AgendaStatusResponse(
        job_id=job_id,
        status=job["status"],
        error=job.get("error"),
        thread_id=job.get("thread_id"),
    )


@app.get("/agenda_result/{job_id}", response_model=AgendaResultResponse)
async def agenda_result(job_id: str):
    job = JOBS.get(job_id)
    if not job:
        raise HTTPException(status_code=404, detail="job_id not found")
    if job["status"] != "done":
        return AgendaResultResponse(
            job_id=job_id,
            status=job["status"],
            error=job.get("error"),
            thread_id=job.get("thread_id"),
            result=None,
        )
    return AgendaResultResponse(
        job_id=job_id,
        status="done",
        result=job["result"],
        error=None,
        thread_id=job.get("thread_id"),
    )
