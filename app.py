# =============================================================================
# Script: app.py
# =============================================================================
# Purpose
#   Expose a REST API that accepts JD, CV, and Skill Tree (plus optional
#   question guidelines) and returns the full agenda JSON generated by
#   AgendaGenerationAgent. Intended for synchronous, single-request use
#   with a configurable timeout.
#
# Behavior
#   - Defines a FastAPI app with a lifespan context:
#       * Startup: prepare lightweight shared resources (if any).
#       * Shutdown: close Mongo connections and clear shared objects.
#   - Provides endpoints:
#       * GET /health: liveness check.
#       * POST /agenda_create: runs the agenda pipeline and returns JSON.
#   - Builds an InputSchema from the request payload and forwards a
#     thread_id through config so downstream agents run accordingly and tag logs correctly.
#   - Normalizes Pydantic outputs to plain dicts before responding.
#   - Logs high-level events and converts internal failures to HTTP errors:
#       * 500 on unhandled exceptions.
#   - Leaves pipeline details (LLM retries, per-node logging) to the
#     underlying agents.
# =============================================================================

import asyncio
import gc
import logging
import os
from contextlib import asynccontextmanager
from datetime import datetime, timezone
from typing import Any, Dict, Optional

import pymongo
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field
from pymongo.errors import PyMongoError

from src.agent.AgendaGenerationAgent import run_agenda_with_logging
from src.mongo_tools import close_all_mongo_connections
from src.schema.input_schema import (
    CandidateProfileSchema,
    InputSchema,
    JobDescriptionSchema,
    SkillTreeSchema,
)

APP_NAME = "agenda_api"
logger = logging.getLogger(APP_NAME)

# API level logging for console warnings
if not logger.handlers:
    logging.basicConfig(
        level=logging.WARNING,
        format="%(asctime)s | %(levelname)s | %(name)s | %(message)s",
    )

# Minimal in-memory job map: status + thread_id only (no results kept)
JOBS: Dict[str, Dict[str, Any]] = {}


@asynccontextmanager
async def lifespan(app: FastAPI):
    try:
        pass
    except Exception:
        logger.exception("Startup initialization failed")
        raise

    yield

    try:
        close_all_mongo_connections()
    except Exception:
        logger.warning("close_all_mongo_connections raised but continuing shutdown")
    JOBS.clear()
    gc.collect()


app = FastAPI(title="Agenda API", version="1.2.0", lifespan=lifespan)

# CORS settings
origins = ["*"]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# ============================
# Models
# ============================
class AgendaRequest(BaseModel):
    job_description: JobDescriptionSchema = Field(..., description="Job description")
    candidate_profile: CandidateProfileSchema = Field(
        ..., description="Candidate CV/profile"
    )
    skill_tree: SkillTreeSchema = Field(..., description="Skill tree")
    question_guidelines: Optional[Dict[str, Any]] = Field(
        default=None, description="Optional question guidelines dict"
    )
    config: Optional[Dict[str, Any]] = Field(
        default=None, description="Optional graph config to override defaults"
    )
    thread_id: Optional[str] = Field(
        default=None, description="Optional thread id for logging/tracing"
    )


class AgendaCreateResponse(BaseModel):
    job_id: str
    status: str
    thread_id: str


class AgendaStatusResponse(BaseModel):
    job_id: str
    status: str
    error: Optional[str] = None
    thread_id: Optional[str] = None


class AgendaResultResponse(BaseModel):
    job_id: str
    status: str
    result: Optional[Dict[str, Any]] = None
    error: Optional[str] = None
    thread_id: Optional[str] = None


# ============================
# Existing mongo helper for guidelines
# ============================
def _mongo_env_for_guidelines() -> tuple[str, str, str]:
    """
    Uses your existing env:
      MONGO_CLIENT, MONGO_DB, MONGO_QUESTION_GENERATION_COLLECTION
    """
    uri = os.environ.get("MONGO_CLIENT")
    db = os.environ.get("MONGO_DB")
    coll = os.environ.get("MONGO_QUESTION_GENERATION_COLLECTION")
    missing = [
        k
        for k, v in {
            "MONGO_CLIENT": uri,
            "MONGO_DB": db,
            "MONGO_QUESTION_GENERATION_COLLECTION": coll,
        }.items()
        if not v
    ]
    if missing:
        raise RuntimeError(f"Missing Mongo env: {', '.join(missing)}")
    return uri, db, coll


def _upsert_question_guidelines(qg_payload: Optional[Dict[str, Any]]) -> None:
    if not qg_payload or not isinstance(qg_payload, dict):
        return

    items = qg_payload.get("question_guidelines")
    if not isinstance(items, list) or not items:
        return

    try:
        uri, db_name, coll_name = _mongo_env_for_guidelines()
    except RuntimeError as e:
        logger.warning("Guidelines upsert skipped: %s", e)
        return

    client = None
    try:
        client = pymongo.MongoClient(uri, serverSelectionTimeoutMS=5000)
        coll = client[db_name][coll_name]
        for raw in items:
            if not isinstance(raw, dict):
                logger.warning("Skipping non-dictionary guideline entry: %r", raw)
                continue
            name = str(raw.get("question_type_name", "")).strip()
            text = str(raw.get("question_guidelines", "")).strip()
            if not name:
                logger.warning("Skipping guideline: empty 'question_type_name'")
                continue
            if not text:
                logger.warning(
                    "Skipping guideline '%s': empty 'question_guidelines'", name
                )
                continue

            doc = {"_id": name, "question_type_name": name, "question_guidelines": text}
            try:
                coll.replace_one({"_id": name}, doc, upsert=True)
            except PyMongoError as e:
                logger.error("Failed to upsert guideline '%s': %s", name, e)
    except PyMongoError as e:
        logger.error("Mongo error during guidelines upsert: %s", e)
    finally:
        if client:
            client.close()


# ============================
# Save + Load agenda docs in Mongo (output DB)
# ============================
def _output_db_params() -> Optional[tuple[str, str]]:
    uri = os.environ.get("MONGO_CLIENT")
    db_name = os.environ.get("MONGO_DB_OUTPUT", "agenda_db_output")
    if not uri:
        logger.warning("MONGO_CLIENT not set; skipping DB IO")
        return None
    return uri, db_name


def _save_agenda_result_to_db(
    job_id: str,
    thread_id: Optional[str],
    req: AgendaRequest,
    result: Optional[Dict[str, Any]],
    error: Optional[str],
) -> None:
    """
    Uses:
        MONGO_CLIENT
        MONGO_DB_OUTPUT (default: agenda_db_output)

    Writes to:
        db: MONGO_DB_OUTPUT
        collection: agenda_output
    """
    params = _output_db_params()
    if not params:
        return
    uri, db_name = params

    client = None
    try:
        client = pymongo.MongoClient(uri, serverSelectionTimeoutMS=5000)
        db = client[db_name]
        coll = db["agenda_output"]

        doc = {
            "job_id": job_id,
            "thread_id": thread_id,
            "request": {
                "job_description": req.job_description.model_dump(),
                "candidate_profile": req.candidate_profile.model_dump(),
                "skill_tree": req.skill_tree.model_dump(),
                "question_guidelines": req.question_guidelines,
            },
            "result": result,
            "error": error,
            "status": "error" if error else "done",
            "created_at": datetime.now(timezone.utc),
        }

        coll.replace_one({"job_id": job_id}, doc, upsert=True)
    except PyMongoError as e:
        logger.error("Failed to save agenda result for job_id=%s: %s", job_id, e)
    finally:
        if client:
            client.close()


def _load_agenda_doc_from_db(job_id: str) -> Optional[Dict[str, Any]]:
    """
    Returns the stored document without the Mongo _id field, or None if not found.
    """
    params = _output_db_params()
    if not params:
        return None
    uri, db_name = params

    client = None
    try:
        client = pymongo.MongoClient(uri, serverSelectionTimeoutMS=5000)
        db = client[db_name]
        coll = db["agenda_output"]
        doc = coll.find_one({"job_id": job_id}, {"_id": 0})
        return doc
    except PyMongoError as e:
        logger.error("Failed to load agenda result for job_id=%s: %s", job_id, e)
        return None
    finally:
        if client:
            client.close()


# ============================
# Helpers
# ============================
def _normalize_output(otpt: Dict[str, Any]) -> Dict[str, Any]:
    norm: Dict[str, Any] = {}
    for k, v in otpt.items():
        key = str(k)
        try:
            if hasattr(v, "model_dump"):
                norm[key] = v.model_dump()
            elif hasattr(v, "dict"):
                norm[key] = v.dict()
            else:
                norm[key] = v
        except Exception:
            norm[key] = v
    return norm


async def _run_job(job_id: str, req: AgendaRequest):
    """
    Runs the agenda job, persists the result/error to DB,
    then removes the job entry from memory and cleans resources.
    """
    try:
        # Track minimal state while running
        job = JOBS.get(job_id)
        if job is not None:
            job["status"] = "running"

        # Optional guideline upsert
        _upsert_question_guidelines(req.question_guidelines)

        inp = InputSchema(
            job_description=req.job_description,
            skill_tree=req.skill_tree,
            candidate_profile=req.candidate_profile,
            question_guidelines=req.question_guidelines or {"question_guidelines": []},
        )

        out = await run_agenda_with_logging(inp, {"thread_id": req.thread_id})
        norm_out = _normalize_output(out)

        # Persist and do NOT keep result in memory
        _save_agenda_result_to_db(
            job_id=job_id,
            thread_id=req.thread_id,
            req=req,
            result=norm_out,
            error=None,
        )

    except Exception as e:
        # Persist the error as a terminal state document
        _save_agenda_result_to_db(
            job_id=job_id,
            thread_id=req.thread_id,
            req=req,
            result=None,
            error=str(e),
        )
    finally:
        # Remove any in-memory reference to this job to free memory
        JOBS.pop(job_id, None)

        # Close any pooled connections held by our code
        try:
            close_all_mongo_connections()
        except Exception:
            logger.debug("close_all_mongo_connections raised during cleanup")

        # Last-resort GC
        gc.collect()


# ============================
# Routes
# ============================
@app.get("/health")
async def health():
    return {"ok": True}


@app.get("/")
async def main():
    return {"message": "Agenda API Home!"}


@app.post("/agenda_create", response_model=AgendaCreateResponse, status_code=202)
async def agenda_create(req: AgendaRequest):
    job_id = req.thread_id
    if not job_id:
        raise HTTPException(status_code=400, detail="thread_id is required")

    # Keep only minimal info in memory
    JOBS[job_id] = {
        "status": "queued",
        "error": None,
        "thread_id": job_id,
    }
    asyncio.create_task(_run_job(job_id, req))

    return AgendaCreateResponse(job_id=job_id, status="queued", thread_id=job_id)


@app.get("/agenda_status/{job_id}", response_model=AgendaStatusResponse)
async def agenda_status(job_id: str):
    # If present in memory (running), report that
    job = JOBS.get(job_id)
    if job:
        return AgendaStatusResponse(
            job_id=job_id,
            status=job["status"],
            error=job.get("error"),
            thread_id=job.get("thread_id"),
        )

    # Otherwise, try DB (job may have finished and been cleaned from memory)
    doc = _load_agenda_doc_from_db(job_id)
    if doc:
        return AgendaStatusResponse(
            job_id=job_id,
            status=str(doc.get("status", "done")),
            error=doc.get("error"),
            thread_id=doc.get("thread_id"),
        )

    raise HTTPException(status_code=404, detail="job_id not found")


@app.get("/agenda_result/{job_id}", response_model=AgendaResultResponse)
async def agenda_result(job_id: str):
    # Results are not kept in memory by design; read from DB
    doc = _load_agenda_doc_from_db(job_id)
    if not doc:
        # If not persisted yet, maybe still running
        job = JOBS.get(job_id)
        if job:
            return AgendaResultResponse(
                job_id=job_id,
                status=job["status"],
                error=job.get("error"),
                thread_id=job.get("thread_id"),
                result=None,
            )
        raise HTTPException(status_code=404, detail="job_id not found")

    return AgendaResultResponse(
        job_id=job_id,
        status=str(doc.get("status", "done")),
        result=doc.get("result"),
        error=doc.get("error"),
        thread_id=doc.get("thread_id"),
    )
